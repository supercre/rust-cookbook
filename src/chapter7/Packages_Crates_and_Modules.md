# 패키지, 크레이트, 모듈로 프로젝트 관리하기

프로그램이 커질수록 코드를 체계적으로 구성하는 것이 점점 더 중요해집니다. 관련된 기능들을 그룹화하고 서로 다른 기능을 가진 코드를 분리함으로써, 특정 기능을 구현한 코드를 어디서 찾을 수 있는지, 그리고 기능의 동작을 어떻게 변경할 수 있는지 명확해집니다.

지금까지 우리가 작성한 프로그램들은 모두 하나의 파일에 하나의 모듈로 되어있었습니다. 프로젝트가 성장함에 따라, 코드를 여러 모듈로 나누고 그 다음에는 여러 파일로 나누어 구성해야 합니다. 하나의 패키지는 여러 개의 바이너리 크레이트와 선택적으로 하나의 라이브러리 크레이트를 포함할 수 있습니다. 패키지가 성장함에 따라, 일부를 별도의 크레이트로 추출하여 외부 의존성이 되게 할 수 있습니다. 이 장에서는 이러한 모든 기법들을 다룹니다. 함께 발전하는 상호 연관된 패키지들의 집합으로 구성된 매우 큰 프로젝트의 경우, Cargo는 _워크스페이스(workspaces)_를 제공하는데, 이는 14장의 "Cargo 워크스페이스" 섹션에서 다룰 것입니다.

또한 구현 세부사항을 캡슐화하는 것에 대해서도 논의할 것입니다. 이를 통해 더 높은 수준에서 코드를 재사용할 수 있습니다: 한번 작업을 구현하면, 다른 코드는 구현이 어떻게 작동하는지 알 필요 없이 공개 인터페이스를 통해 당신의 코드를 호출할 수 있습니다. 코드를 작성하는 방식에 따라 어떤 부분이 다른 코드에서 사용할 수 있는 공개 부분이 되고, 어떤 부분이 변경할 권리를 보유하는 비공개 구현 세부사항이 되는지가 정의됩니다. 이는 머릿속에 담아야 할 세부사항의 양을 제한하는 또 다른 방법입니다.

관련된 개념으로 스코프(scope)가 있습니다: 코드가 작성되는 중첩된 컨텍스트는 "스코프 내에 있다"고 정의된 이름들의 집합을 가집니다. 코드를 읽고, 쓰고, 컴파일할 때, 프로그래머와 컴파일러는 특정 지점의 특정 이름이 변수, 함수, 구조체, 열거형, 모듈, 상수 또는 다른 항목을 가리키는지, 그리고 그 항목이 무엇을 의미하는지 알아야 합니다. 스코프를 만들고 어떤 이름이 스코프 안에 있거나 밖에 있는지 변경할 수 있습니다. 같은 스코프 안에 같은 이름을 가진 두 항목을 가질 수 없으며, 이름 충돌을 해결하기 위한 도구들이 있습니다.

Rust는 코드의 구성, 어떤 세부사항이 공개되는지, 어떤 세부사항이 비공개인지, 그리고 프로그램의 각 스코프에서 어떤 이름들이 있는지를 관리할 수 있게 해주는 여러 기능들을 가지고 있습니다. 이러한 기능들은 때로는 _모듈 시스템_이라고 총칭되며, 다음과 같은 것들을 포함합니다:

* **패키지(Packages):** 크레이트를 빌드하고, 테스트하고, 공유할 수 있게 해주는 Cargo 기능
* **크레이트(Crates):** 라이브러리나 실행 파일을 생성하는 모듈의 트리
* **모듈(Modules)** 과 **use:** 경로의 구성, 스코프, 비공개성을 제어할 수 있게 해줌
* **경로(Paths):** 구조체, 함수, 모듈과 같은 항목을 명명하는 방법

이 장에서는 이러한 모든 기능들을 다루고, 이들이 어떻게 상호작용하는지 논의하며, 스코프를 관리하기 위해 이들을 어떻게 사용하는지 설명할 것입니다. 이 장이 끝나면 모듈 시스템에 대한 견고한 이해를 갖게 되고, 전문가처럼 스코프를 다룰 수 있게 될 것입니다!
