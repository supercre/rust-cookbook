# 스코프와 비공개성을 제어하기 위한 모듈 정의하기

이 섹션에서는 모듈과 모듈 시스템의 다른 부분들, 즉 항목을 명명할 수 있게 해주는 _경로(paths)_, 경로를 스코프로 가져오는 `use` 키워드, 항목을 공개하게 만드는 `pub` 키워드에 대해 이야기할 것입니다. 또한 `as` 키워드, 외부 패키지, 그리고 글로브 연산자에 대해서도 논의할 것입니다.

## 모듈 치트 시트

모듈과 경로의 세부사항에 들어가기 전에, 여기서는 컴파일러에서 모듈, 경로, `use` 키워드, `pub` 키워드가 어떻게 작동하는지, 그리고 대부분의 개발자들이 어떻게 코드를 구성하는지에 대한 빠른 참조를 제공합니다. 이 장 전체에서 이러한 규칙들의 예제를 살펴볼 것이지만, 이는 모듈이 어떻게 작동하는지 상기시키기 위한 좋은 참조 지점입니다.

* **크레이트 루트에서 시작하기**: 크레이트를 컴파일할 때, 컴파일러는 먼저 컴파일할 코드를 찾기 위해 크레이트 루트 파일(보통 라이브러리 크레이트의 경우 _src/lib.rs_ 또는 바이너리 크레이트의 경우 _src/main.rs_)을 살펴봅니다.
* **모듈 선언하기**: 크레이트 루트 파일에서 `mod garden;`과 같이 새로운 모듈을 선언할 수 있습니다. 컴파일러는 다음과 같은 위치에서 모듈의 코드를 찾습니다:
  * `mod garden` 뒤의 세미콜론을 대체하는 중괄호 안에 인라인으로
  * _src/garden.rs_ 파일에서
  * _src/garden/mod.rs_ 파일에서
* **하위 모듈 선언하기**: 크레이트 루트가 아닌 다른 파일에서 하위 모듈을 선언할 수 있습니다. 예를 들어, _src/garden.rs_에서 `mod vegetables;`를 선언할 수 있습니다. 컴파일러는 부모 모듈의 이름을 딴 디렉토리 내에서 다음과 같은 위치에서 하위 모듈의 코드를 찾습니다:
  * 세미콜론 대신 중괄호 안에 `mod vegetables` 바로 뒤에 인라인으로
  * _src/garden/vegetables.rs_ 파일에서
  * _src/garden/vegetables/mod.rs_ 파일에서
* **모듈 내 코드에 대한 경로**: 모듈이 크레이트의 일부가 되면, 비공개성 규칙이 허용하는 한, 크레이트 내의 다른 곳에서 경로를 사용하여 해당 모듈의 코드를 참조할 수 있습니다. 예를 들어, 정원 채소 모듈의 `Asparagus` 타입은 `crate::garden::vegetables::Asparagus`에서 찾을 수 있습니다.
* **비공개 vs 공개**: 모듈 내의 코드는 기본적으로 부모 모듈로부터 비공개입니다. 모듈을 공개하려면 `mod` 대신 `pub mod`로 선언하세요. 공개 모듈 내의 항목들도 공개하려면, 그들의 선언 앞에 `pub`을 사용하세요.
* **`use` 키워드**: 스코프 내에서 `use` 키워드는 긴 경로의 반복을 줄이기 위해 항목에 대한 바로가기를 생성합니다. `crate::garden::vegetables::Asparagus`를 참조할 수 있는 어떤 스코프에서든, `use crate::garden::vegetables::Asparagus;`로 바로가기를 만들 수 있으며, 그 이후에는 스코프 내에서 해당 타입을 사용하기 위해 `Asparagus`만 작성하면 됩니다.

여기서, 이러한 규칙들을 설명하는 `backyard`라는 이름의 바이너리 크레이트를 만듭니다. 크레이트의 디렉토리(역시 `backyard`라는 이름)는 다음과 같은 파일과 디렉토리를 포함합니다:

```text
backyard
├── Cargo.lock
├── Cargo.toml
└── src
    ├── garden
    │   └── vegetables.rs
    ├── garden.rs
    └── main.rs
```

이 경우 크레이트 루트 파일은 _src/main.rs_이며, 다음과 같은 내용을 포함합니다:

파일명: src/main.rs

```rust
use crate::garden::vegetables::Asparagus;

pub mod garden;

fn main() {
    let plant = Asparagus {};
    println!("I'm growing {plant:?}!");
}
```

`pub mod garden;` 줄은 컴파일러에게 _src/garden.rs_에서 찾은 코드를 포함하라고 지시합니다. 이 코드는 다음과 같습니다:

파일명: src/garden.rs

```rust
pub mod vegetables;
```

여기서 `pub mod vegetables;`는 _src/garden/vegetables.rs_의 코드도 포함된다는 것을 의미합니다. 그 코드는 다음과 같습니다:

```rust
#[derive(Debug)]
pub struct Asparagus {}
```

이제 이러한 규칙들의 세부사항을 살펴보고 실제로 어떻게 작동하는지 보여드리겠습니다!

## 모듈에서 관련 코드 그룹화하기

_모듈(modules)_은 가독성과 쉬운 재사용을 위해 크레이트 내의 코드를 구성할 수 있게 해줍니다. 모듈은 또한 항목의 _비공개성(privacy)_을 제어할 수 있게 해주는데, 이는 모듈 내의 코드가 기본적으로 비공개이기 때문입니다. 비공개 항목은 외부에서 사용할 수 없는 내부 구현 세부사항입니다. 우리는 모듈과 그 안의 항목들을 공개하도록 선택할 수 있으며, 이는 외부 코드가 그것들을 사용하고 의존할 수 있도록 노출시킵니다.

예를 들어, 레스토랑의 기능을 제공하는 라이브러리 크레이트를 작성해 보겠습니다. 우리는 함수의 시그니처를 정의하되, 레스토랑의 구현보다는 코드의 구성에 집중하기 위해 그들의 본문은 비워둘 것입니다.

레스토랑 업계에서는 레스토랑의 일부를 _프론트 오브 하우스(front of house)_라고 하고 다른 부분을 _백 오브 하우스(back of house)_라고 합니다. 프론트 오브 하우스는 고객이 있는 곳입니다; 여기에는 호스트가 고객을 자리에 앉히는 곳, 서버가 주문을 받고 결제를 처리하는 곳, 바텐더가 음료를 만드는 곳이 포함됩니다. 백 오브 하우스는 셰프와 요리사가 주방에서 일하는 곳, 설거지꾼이 청소하는 곳, 관리자가 행정 업무를 하는 곳입니다.

크레이트를 이런 방식으로 구성하기 위해, 우리는 그 기능들을 중첩된 모듈로 구성할 수 있습니다. `cargo new restaurant --lib`를 실행하여 `restaurant`라는 새로운 라이브러리를 만듭니다. 그런 다음 목록 7-1의 코드를 _src/lib.rs_에 입력하여 일부 모듈과 함수 시그니처를 정의합니다; 이 코드는 프론트 오브 하우스 섹션입니다.

파일명: src/lib.rs

```rust
mod front_of_house {
    mod hosting {
        fn add_to_waitlist() {}

        fn seat_at_table() {}
    }

    mod serving {
        fn take_order() {}

        fn serve_order() {}

        fn take_payment() {}
    }
}
```

목록 7-1: 다른 모듈을 포함하는 `front_of_house` 모듈, 그 모듈들은 함수를 포함함

우리는 `mod` 키워드 뒤에 모듈의 이름(이 경우 `front_of_house`)을 붙여 모듈을 정의합니다. 그런 다음 모듈의 본문은 중괄호 안에 들어갑니다. 모듈 내부에서는 이 경우 `hosting`과 `serving` 모듈처럼 다른 모듈을 배치할 수 있습니다. 모듈은 또한 구조체, 열거형, 상수, 트레이트, 그리고 목록 7-1에서처럼 함수와 같은 다른 항목들의 정의를 포함할 수 있습니다.

모듈을 사용함으로써, 우리는 관련된 정의들을 함께 그룹화하고 그것들이 왜 관련되어 있는지 이름을 지을 수 있습니다. 이 코드를 사용하는 프로그래머들은 모든 정의를 읽어야 하는 대신 그룹을 기반으로 코드를 탐색할 수 있어, 그들에게 관련된 정의를 더 쉽게 찾을 수 있습니다. 이 코드에 새로운 기능을 추가하는 프로그래머들은 프로그램을 체계적으로 유지하기 위해 코드를 어디에 배치해야 하는지 알 수 있습니다.

앞서, _src/main.rs_와 _src/lib.rs_를 크레이트 루트라고 부른다고 언급했습니다. 그들의 이름이 그런 이유는 이 두 파일 중 하나의 내용이 크레이트의 모듈 구조의 루트에 있는 `crate`라는 이름의 모듈을 형성하기 때문입니다. 이를 _모듈 트리(module tree)_라고 합니다.

목록 7-2는 목록 7-1의 구조에 대한 모듈 트리를 보여줍니다.

```text
crate
 └── front_of_house
     ├── hosting
     │   ├── add_to_waitlist
     │   └── seat_at_table
     └── serving
         ├── take_order
         ├── serve_order
         └── take_payment
```

목록 7-2: 목록 7-1의 코드에 대한 모듈 트리

이 트리는 일부 모듈이 다른 모듈 안에 어떻게 중첩되어 있는지 보여줍니다; 예를 들어, `hosting`은 `front_of_house` 안에 중첩되어 있습니다. 트리는 또한 일부 모듈이 _형제(siblings)_임을 보여주는데, 이는 그것들이 같은 모듈 안에 정의되어 있다는 것을 의미합니다; `hosting`과 `serving`은 `front_of_house` 안에 정의된 형제입니다. 모듈 A가 모듈 B 안에 포함되어 있다면, 우리는 모듈 A가 모듈 B의 _자식(child)_이고 모듈 B가 모듈 A의 _부모(parent)_라고 말합니다. 전체 모듈 트리가 암묵적인 `crate`라는 이름의 모듈 아래에 루트를 두고 있다는 점에 주목하세요.

모듈 트리는 컴퓨터의 파일시스템의 디렉토리 트리를 연상시킬 수 있습니다; 이는 매우 적절한 비교입니다! 파일시스템의 디렉토리처럼, 모듈을 사용하여 코드를 구성합니다. 그리고 디렉토리의 파일처럼, 우리는 모듈을 찾을 방법이 필요합니다. 