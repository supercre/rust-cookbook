## panic!이냐, panic!이 아니냐, 그것이 문제로다
  
그러면 언제 `panic!`을 써야 하고 언제 `Result`를 반환할지는 어떻게 결정해야 할까요? 코드가 패닉을 일으킬 때는 복구할 방법이 없습니다. 복구 가능한 방법이 있든 없든 간에 에러 상황에 대해 `panic!`을 호출할 수 있지만, 그렇게 되면 호출하는 코드를 대신하여 현 상황은 복구 불가능한 것이라고 결정을 내리는 꼴이 됩니다. `Result` 값을 반환하는 선택을 한다면 호출하는 쪽에게 옵션을 제공하는 것입니다. 호출하는 코드 쪽에서는 상황에 적합한 방식으로 복구를 시도할 수도 있고, 혹은 현재 상황의 `Err`은 복구 불가능하다고 결론을 내리고 `panic!`을 호출하여 복구 가능한 에러를 복구 불가능한 것으로 바꿔놓을 수도 있습니다.   
그러므로 실패할지도 모르는 함수를 정의할 때는 기본적으로 `Result`를 반환하는 것이 좋은 선택입니다.

예제, 프로토타입, 테스트 같은 상황에서는 `Result`를 반환하는 대신 패닉을 일으키는 코드가 더 적절합니다. 왜 그런지 탐구해 보고, 사람으로서의 여러분이라면 실패할 리 없는 코드라는 것을 알 수 있지만, 컴파일러는 이유를 파악할 수 없는 경우에 대해서도 논의해 봅시다. 그리고 라이브러리 코드에 패닉을 추가해야 할지 말지를 어떻게 결정할까에 대한 일반적인 가이드라인을 내림으로써 결론짓겠습니다.


### 예제, 프로토타입 코드, 그리고 테스트  
  
어떤 개념을 묘사하기 위한 예제를 작성 중이라면, 견고한 에러 처리 코드를 포함시키는 것이 오히려 예제의 명확성을 떨어트릴 수도 있습니다. 예제 코드 내에서는 `panic!`을 일으킬 수 있는 `unwrap` 같은 메서드의 호출이 애플리케이션의 에러 처리가 필요한 곳을 뜻하는 방식으로 해석될 수 있는데, 이러한 에러 처리는 코드의 나머지 부분이 하는 일에 따라 달라질 수 있습니다.

비슷한 상황으로 에러를 어떻게 처리할지 결정할 준비가 되기 전이라면, `unwrap`과 `expect` 메서드가 프로토타이핑할 때 매우 편리합니다. 이 함수들은 코드를 더 견고하게 만들 준비가 되었을 때를 위해서 명확한 표시를 남겨 둡니다.

만일 테스트 내에서 메서드 호출이 실패한다면, 해당 메서드가 테스트 중인 기능이 아니더라도 전체 테스트를 실패시키도록 합니다. `panic!`이 테스트의 실패를 표시하는 방식이므로, `unwrap`이나 `expect`의 호출이 정확히 그렇게 만들어줍니다.  
  
### 여러분이 컴파일러보다 더 많은 정보를 가지고 있을 때  
  
`Result`가 `Ok` 값을 가지고 있을 거라 확신할만한 논리적 근거가 있지만, 컴파일러가 그 논리를 이해할 수 없는 경우라면, `unwrap`혹은 `expect`를 호출하는 것이 적절할 수 있습니다. 어떤 연산이든 간에 특정한 상황에서는 논리적으로 불가능할지라도 기본적으로는 실패할 가능성을 가지고 있는 코드를 호출하는 것이므로, 처리가 필요한 `Result` 값이 나오게 됩니다. 손수 코드를 조사하여 `Err` 배리언트가 나올리 없음을 확신할 수 있다면 `unwrap`을 호출해도 아무런 문제가 없으며, `expect`의 문구에 `Err` 배리언트가 있으면 안 될 이유를 적어주는 것이 더 좋을 것입니다. 아래에 예제가 있습니다.

``` rust,editable

    use std::net::IpAddr;

    let home: IpAddr = "127.0.0.1"
        .parse()
        .expect("Hardcoded IP address should be valid");

```
여기서는 하드코딩된 문자열을 파싱하여 `IpAddr` 인스턴스를 만드는 중입니다. `127.0.0.1`이 유효한 IP 주소라는 사실을 알 수 있으므로, 여기서는 `expect`의 사용이 허용됩니다. 하지만 하드코딩된 유효한 문자열이라는 사실이 `parse` 메서드의 반환 타입을 변경해 주지는 않습니다. 여전히 `Result` 값이 나오고, 컴파일러는 마치 `Err` 배리언트가 나올 가능성이 여전히 있는 것처럼 `Result`를 처리하도록 요청할 것인데, 그 이유는 이 문자열이 항상 유효한 IP 주소라는 사실을 알 수 있을 만큼 컴파일러가 똑똑하지 않기 때문입니다. 만일 IP 주소 문자열이 프로그램에 하드코딩된 것이 아니라 사용자로부터 입력되었다면, 그래서 실패할 가능성이 생겼다면, 더 견고한 방식으로 `Result`를 처리할 필요가 분명히 있습니다. `expect`에 이 IP 주소가 하드코딩 되었다는 가정을 언급하는 것은 향후에 IP 주소가 다른 곳으로부터 가져올 필요가 생길 경우 `expect`를 더 나은 에러 처리 코드로 수정하도록 재촉할 것입니다.  
  
### 에러 처리를 위한 가이드라인
  
