# 해시 맵에 연관된 값과 함께 키 저장하기

마지막 공통 컬렉션은 해시 맵입니다. `HashMap<K, V>` 유형은 이러한 키와 값을 메모리에 배치하는 방법을 결정하는 해싱 함수를 사용하여 `K` 유형의 키를 `V` 유형의 값에 매핑하는 것을 저장합니다. 많은 프로그래밍 언어가 이러한 종류의 데이터 구조를 지원하지만 해시, 맵, 객체, 해시 테이블, 사전 또는 연관 배열 등 다른 이름을 사용하는 경우가 많습니다.

해시 맵은 벡터처럼 인덱스가 아닌 어떤 유형이든 가능한 키를 사용해 데이터를 조회하려는 경우에 유용합니다. 예를 들어, 게임에서 각 키는 팀의 이름이고 값은 각 팀의 점수인 해시 맵으로 각 팀의 점수를 추적할 수 있습니다. 팀 이름이 주어지면 해당 팀의 점수를 검색할 수 있습니다.

이 섹션에서는 해시맵의 기본 API에 대해 살펴보겠지만, 표준 라이브러리에서 `HashMap<K, V>` 에 정의된 함수에는 더 많은 유용한 기능들이 숨어 있습니다. 항상 그렇듯이 자세한 내용은 표준 라이브러리 설명서를 확인하세요.

## 새 해시 맵 만들기

빈 해시 맵을 만드는 한 가지 방법은 `new` 를 사용하고 `insert` 를 사용하여 요소를 추가하는 것입니다. 목록 8-20에서는 이름이 파란색과 노란색인 두 팀의 점수를 추적하고 있습니다. _Blue_ 팀은 10점으로 시작하고 _Yellow_ 팀은 50점으로 시작합니다.

```rust,editable
    use std::collections::HashMap;

    let mut scores = HashMap::new();

    scores.insert(String::from("Blue"), 10);
    scores.insert(String::from("Yellow"), 50);
```
**목록 8-20: 새 해시 맵 만들기 및 일부 키와 값 삽입하기**

먼저 표준 라이브러리의 컬렉션 부분에서 `HashMap`을 `use` 해야 한다는 점에 유의하세요. 이 컬렉션은 세 가지 일반적인 컬렉션 중 가장 사용 빈도가 낮기 때문에 프렐류드에서 자동으로 제공되는 기능에 포함되지 않습니다. 또한 해시맵은 표준 라이브러리에서 지원되는 기능이 적으며, 예를 들어 해시맵을 구성하는 기본 제공 매크로가 없습니다.

## 해시 맵의 값에 액세스하기

목록 8-21에 표시된 것처럼 `get` 메서드에 키를 제공하여 해시 맵에서 값을 가져올 수 있습니다.

```rust,editable
    use std::collections::HashMap;

    let mut scores = HashMap::new();

    scores.insert(String::from("Blue"), 10);
    scores.insert(String::from("Yellow"), 50);

    let team_name = String::from("Blue");
    let score = scores.get(&team_name).copied().unwrap_or(0);
```

**목록 8-21: 해시 맵에 저장된 Blue 팀의 점수에 액세스하기**

여기서 점수에는 _Blue_ 팀과 연관된 값이 있으며 결과는 10이 됩니다. `get` 메서드는 `Option<&V>`를 반환하며, 해시 맵에 해당 키에 대한 값이 없는 경우 `get` 은 `None`을 반환합니다. 이 프로그램은 복사된 값을 호출하여 `Option<&i32>`가 아닌 `Option<i32>`를 가져온 다음, `unwrap_or`를 호출하여 점수에 해당 키에 대한 항목이 없는 경우 점수를 0으로 설정하여 옵션을 처리합니다.

벡터에서와 비슷한 방식으로 해시 맵의 각 키-값 쌍을 반복할 수 있으며, `for` 루프를 사용할 수 있습니다:

```rust,editable
    use std::collections::HashMap;

    let mut scores = HashMap::new();

    scores.insert(String::from("Blue"), 10);
    scores.insert(String::from("Yellow"), 50);

    for (key, value) in &scores {
        println!("{key}: {value}");
    }
```

이 코드는 각 쌍을 임의의 순서로 인쇄합니다:

```
Yellow: 50
Blue: 10
```

## 해시 맵 및 소유권

`i32`와 같이 `Copy` 특성을 구현하는 유형의 경우 값이 해시 맵에 복사됩니다. 문자열과 같이 소유된 값의 경우, 목록 8-22에 표시된 것처럼 값이 이동되고 해시 맵이 해당 값의 소유자가 됩니다.

```rust,editable
    use std::collections::HashMap;

    let field_name = String::from("Favorite color");
    let field_value = String::from("Blue");

    let mut map = HashMap::new();
    map.insert(field_name, field_value);
    // field_name and field_value are invalid at this point, try using them and
    // see what compiler error you get!
```

**목록 8-22: 키와 값이 삽입된 후 해시 맵에 의해 소유됨을 표시하기**

`field_name` 과 `field_value` 변수는 `insert` 호출을 통해 해시 맵으로 이동한 후에는 사용할 수 없습니다.

해시 맵에 값에 대한 참조를 삽입하면 해당 값은 해시 맵으로 이동되지 않습니다. 참조가 가리키는 값은 적어도 해시 맵이 유효한 기간 동안 유효해야 합니다. 이러한 문제에 대해서는 10장의 ["수명을 사용하여 참조 유효성 검사하기"](https://doc.rust-lang.org/book/ch10-03-lifetime-syntax.html#validating-references-with-lifetimes) 섹션에서 자세히 설명합니다.

## 해시 맵 갱신하기

키와 값 쌍의 수는 늘릴 수 있지만, 각 고유 키에는 한 번에 하나의 값만 연결할 수 있습니다(예를 들어 블루 팀과 옐로우 팀 모두 점수 해시 맵에 값 10을 저장할 수 있음).

해시 맵의 데이터를 변경하려는 경우 키에 이미 값이 할당된 경우를 어떻게 처리할지 결정해야 합니다. 이전 값을 완전히 무시하고 새 값으로 대체할 수 있습니다. 이전 값을 유지하고 새 값을 무시하고 키에 이미 값이 없는 경우에만 새 값을 추가할 수 있습니다. 또는 이전 값과 새 값을 결합할 수도 있습니다. 각각의 방법을 살펴보겠습니다!

## 값 덮어쓰기

해시 맵에 키와 값을 삽입한 다음 동일한 키를 다른 값으로 삽입하면 해당 키와 연관된 값이 바뀝니다. 목록 8-23의 코드에서는 삽입을 두 번 호출하지만, Blue 팀의 키에 대한 값을 두 번 모두 삽입하기 때문에 해시 맵에는 키-값 쌍이 하나만 포함됩니다.

```rust,editable
    use std::collections::HashMap;

    let mut scores = HashMap::new();

    scores.insert(String::from("Blue"), 10);
    scores.insert(String::from("Blue"), 25);

    println!("{scores:?}");
```

**목록 8-23: 특정 키로 저장된 값 바꾸기**

이 코드는 `{"Blue": 25}` 를 출력합니다. 원래 값인 10을 덮어썼습니다.

## 키가 없는 경우, 키와 값 추가하기

특정 키가 해시 맵에 값으로 이미 존재하는지 확인한 다음 다음과 같은 작업을 수행하는 것이 일반적입니다. 키가 해시 맵에 존재하면 기존 값을 그대로 유지하고, 키가 존재하지 않으면 해당 키와 해당 값을 삽입합니다.

해시 맵에는 확인하려는 키를 매개변수로 받는 `entry` 라는 특수 API가 있습니다. 항목 메서드의 반환 값은 존재할 수도 있고 존재하지 않을 수도 있는 값을 나타내는 Entry라는 열거형입니다. Yellow 팀의 키에 연관된 값이 있는지 확인하려고 한다고 가정해 보겠습니다. 없는 경우 50이라는 값을 삽입하고, Blue 팀에 대해서도 동일한 값을 삽입하려고 합니다. `entry` API를 사용하면 코드는 목록 8-24와 같습니다.

```rust,editable
    use std::collections::HashMap;

    let mut scores = HashMap::new();
    scores.insert(String::from("Blue"), 10);

    scores.entry(String::from("Yellow")).or_insert(50);
    scores.entry(String::from("Blue")).or_insert(50);

    println!("{scores:?}");
```

**목록 8-24: 키에 값이 없는 경우에만 삽입하는 `entry` 메소드 사용**

`Entry`의 `or_insert` 메서드는 해당 `Entry` 키가 존재하면 해당 키의 값에 대한 변경 가능한 참조를 반환하고, 존재하지 않으면 이 키의 새 값으로 파라미터를 삽입하고 새 값에 대한 변경 가능한 참조를 반환하도록 정의되어 있습니다. 이 기법은 로직을 직접 작성하는 것보다 훨씬 깔끔하며 차용 검사기에서도 더 잘 작동합니다.

목록 8-24의 코드를 실행하면 `{"Yellow": 50, "Blue": 10}`을 출력합니다. 첫 번째 항목 호출은 Yellow 팀에 아직 값이 없으므로 50 값을 가진 Yellow 팀의 키를 삽입합니다. 두 번째 항목 호출은 Blue 팀에 이미 10이라는 값이 있으므로 해시 맵을 변경하지 않습니다.

## 이전 값을 기반으로 값 업데이트하기

해시 맵의 또 다른 일반적인 사용 사례는 키의 값을 조회한 다음 이전 값을 기반으로 업데이트하는 것입니다. 예를 들어 목록 8-25는 텍스트에서 각 단어가 몇 번이나 나타나는지 계산하는 코드를 보여줍니다. 단어를 키로 하는 해시 맵을 사용하고 값을 증가시켜 해당 단어를 몇 번이나 보았는지 추적합니다. 처음 본 단어인 경우 먼저 값 0을 삽입합니다.

```rust,editable
    use std::collections::HashMap;

    let text = "hello world wonderful world";

    let mut map = HashMap::new();

    for word in text.split_whitespace() {
        let count = map.entry(word).or_insert(0);
        *count += 1;
    }

    println!("{map:?}");
```

**목록 8-25: 단어와 개수를 저장하는 해시 맵을 사용하여 단어의 발생 횟수 계산하기**

이 코드는 `{"world": 2, "hello": 1, "wonderful": 1}`. 동일한 키-값 쌍이 다른 순서로 인쇄되는 것을 볼 수 있습니다. ["해시 맵의 값에 액세스하기"](#해시-맵의-값에-액세스하기) 섹션에서 해시 맵에 대한 반복 작업은 임의의 순서로 수행된다는 점을 기억하세요.

`split_whitespace` 메서드는 텍스트 값의 공백으로 구분된 하위 조각에 대한 이터레이터를 반환합니다. `or_insert` 메서드는 지정된 키의 값에 대한 변경 가능한 참조(`&mut V`)를 반환합니다. 여기서는 해당 변경 가능한 참조를 `count` 변수에 저장하므로 해당 값에 할당하려면 먼저 별표(`*`)를 사용하여 `count`를 역참조해야 합니다. 변경 가능한 참조는 `for` 루프가 끝날 때 범위를 벗어나므로 이러한 모든 변경은 차용 규칙에 따라 안전하며 허용됩니다.

## 해시 함수

기본적으로 해시맵은 해시 테이블과 관련된 서비스 거부(DoS) 공격에 대한 저항력을 제공할 수 있는 SipHash라는 해싱 함수를 사용합니다 [^siphash]. 이것은 가장 빠른 해싱 알고리즘은 아니지만 성능 저하로 인한 보안 강화를 위해 그만한 가치가 있습니다. 코드를 프로파일링한 결과 기본 해시 함수가 목적에 비해 너무 느리다고 판단되면 다른 해셔를 지정하여 다른 함수로 전환할 수 있습니다. 해셔는 `BuildHasher` 특성을 구현하는 유형입니다. 10장에서 특성과 이를 구현하는 방법에 대해 설명하겠습니다. [crates.io](https://crates.io/)에는 많은 일반적인 해싱 알고리즘을 구현하는 해셔를 제공하는 다른 Rust 사용자들이 공유하는 라이브러리가 있으므로 처음부터 자체 해셔를 구현할 필요는 없습니다.

[^siphash]: [https://en.wikipedia.org/wiki/SipHash](https://en.wikipedia.org/wiki/SipHash)

## 요약

벡터, 문자열 및 해시 맵은 데이터를 저장, 액세스 및 수정해야 할 때 프로그램에서 필요한 많은 기능을 제공합니다. 이제 여러분이 풀 수 있는 몇 가지 연습 문제를 소개합니다:

1. 정수 목록이 주어지면 벡터를 사용하여 목록의 중앙값(정렬된 경우 중간 위치의 값)과 모드(가장 자주 발생하는 값, 해시 맵이 도움이 될 것입니다.)를 반환합니다.
2. 문자열을 돼지 라틴어로 변환합니다. 각 단어의 첫 자음이 단어의 끝으로 이동하고 ay가 추가되므로 first는 irst-fay가 됩니다. 모음으로 시작하는 단어는 대신 끝에 건초가 추가됩니다(애플은 애플-헤이가 됩니다). UTF-8 인코딩에 대한 자세한 내용을 기억하세요!
3. 해시 맵과 벡터를 사용하여 사용자가 회사 내 부서에 직원 이름을 추가할 수 있는 텍스트 인터페이스를 만듭니다(예: "엔지니어링에 샐리 추가" 또는 "영업에 아미르 추가"). 그런 다음 사용자가 알파벳 순으로 정렬된 부서의 모든 사람 또는 회사 내 모든 사람의 부서별 목록을 검색할 수 있도록 하세요.

표준 라이브러리 API 문서에는 이러한 연습에 도움이 되는 벡터, 문자열 및 해시 맵의 메서드가 설명되어 있습니다!

작업이 실패할 수 있는 더 복잡한 프로그램을 다루고 있으므로 오류 처리에 대해 논의하기에 완벽한 시기입니다. 다음 시간에 다루겠습니다!
