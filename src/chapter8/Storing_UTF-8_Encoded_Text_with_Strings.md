# UTF-8로 인코딩된 텍스트를 스트링으로 저장하기

4장에서 문자열에 대해 이야기했지만 이제 좀 더 자세히 살펴보겠습니다. Rust를 처음 접하는 사람들은 보통 세 가지 이유가 복합적으로 작용하여 문자열에 막히게 됩니다: 가능한 오류를 노출하는 Rust의 성향, 많은 프로그래머가 생각하는 것보다 더 복잡한 데이터 구조인 문자열, 그리고 UTF-8입니다. 이러한 요소들이 결합되어 다른 프로그래밍 언어에서는 어렵게 느껴질 수 있습니다.

컬렉션의 맥락에서 문자열을 논의하는 이유는 문자열이 바이트의 모음으로 구현되기 때문이며, 이러한 바이트가 텍스트로 해석될 때 유용한 기능을 제공하기 위한 몇 가지 메서드도 함께 설명합니다. 이 섹션에서는 모든 컬렉션 유형에 있는 `String` 에 대한 작업(예: 생성, 업데이트, 읽기)에 대해 설명합니다. 또한 `String` 이 다른 컬렉션과 다른 방식, 즉 사람과 컴퓨터가 `String` 데이터를 해석하는 방법의 차이로 인해 `String` 으로 색인하는 것이 어떻게 복잡한지에 대해서도 설명합니다.

## 문자열이 뭔가요?

먼저 문자열이라는 용어의 의미를 정의하겠습니다. Rust의 핵심 언어에는 단 하나의 문자열 유형이 있으며, 이는 일반적으로 차용된 형식인 `&str` 에서 볼 수 있는 문자열 슬라이스 `str` 입니다. 4장에서는 다른 곳에 저장된 일부 UTF-8 인코딩된 문자열 데이터에 대한 참조인 문자열 슬라이스에 대해 이야기했습니다. 예를 들어 문자열 리터럴은 프로그램의 바이너리에 저장되므로 문자열 슬라이스입니다.

핵심 언어로 코딩되지 않고 Rust의 표준 라이브러리에서 제공되는 `String` 유형은 성장 가능하고, 변경 가능하며, 소유된 UTF-8로 인코딩된 문자열 유형입니다. Rust에서 "문자열"을 언급할 때, 이는 `String` 또는 문자열 슬라이스 `&str` 유형 중 하나를 지칭하는 것이 아니라 둘 다를 지칭할 수 있습니다. 이 섹션은 주로 `String` 에 관한 것이지만, 두 유형 모두 Rust의 표준 라이브러리에서 많이 사용되며 문자열과 문자열 조각은 모두 UTF-8로 인코딩됩니다.

## 새 문자열 만들기

`String` 은 실제로 몇 가지 추가 보장, 제한 및 기능을 갖춘 바이트열 벡터의 래퍼로 구현되기 때문에 `Vec<T>` 에서 사용할 수 있는 동일한 연산 중 상당수를 문자열에서도 사용할 수 있습니다. 목록 8-11에 표시된 인스턴스를 생성하는 새 함수는 `Vec<T>` 와 `String` 에서 동일한 방식으로 작동하는 함수의 예입니다.

```rust,editable

    let mut s = String::new();

```
**목록 8-11: 새로운 빈 `String` 만들기**

이 줄은 `s` 라는 새로운 빈 문자열을 생성하고, 여기에 데이터를 로드할 수 있습니다. 종종 문자열을 시작하기 위한 초기 데이터가 필요할 때가 있습니다. 이를 위해 문자열 리터럴처럼 `Display` 특성을 구현하는 모든 유형에서 사용할 수 있는 `to_string` 메서드를 사용합니다. 목록 8-12에는 두 가지 예가 나와 있습니다.

```rust,editable
    let data = "initial contents";

    let s = data.to_string();

    // the method also works on a literal directly:
    let s = "initial contents".to_string();
```
**목록 8-12: 문자열 리터럴에서 `String` 을 생성하기 위해 `to_string` 메서드 사용**

이 코드는 `initial contents` 가 포함된 문자열을 생성합니다.

`String::from` 함수를 사용하여 문자열 리터럴에서 `String` 을 만들 수도 있습니다. 목록 8-13의 코드는 목록 8-12의 `to_string` 을 사용하는 코드와 동일합니다.

```rust,editable
    let s = String::from("initial contents");
```

**목록 8-13: String::from 함수를 사용하여 문자열 리터럴에서 `String` 만들기**

문자열은 매우 다양한 용도로 사용되기 때문에 문자열에 대한 다양한 일반 API를 사용할 수 있으며, 이는 우리에게 많은 옵션을 제공합니다. 그중 일부는 중복되어 보일 수 있지만 모두 각자의 역할이 있습니다! 이 경우 `String::from` 과 `to_string` 은 동일한 작업을 수행하므로 어떤 것을 선택하느냐는 스타일과 가독성의 문제입니다.

문자열은 UTF-8로 인코딩되므로 목록 8-14에 표시된 것처럼 적절하게 인코딩된 데이터를 포함할 수 있다는 점을 기억하세요.

```rust,editable
    let hello = String::from("السلام عليكم");
    let hello = String::from("Dobrý den");
    let hello = String::from("Hello");
    let hello = String::from("שלום");
    let hello = String::from("नमस्ते");
    let hello = String::from("こんにちは");
    let hello = String::from("안녕하세요");
    let hello = String::from("你好");
    let hello = String::from("Olá");
    let hello = String::from("Здравствуйте");
    let hello = String::from("Hola");
```
**목록 8-14: 서로 다른 언어로 된 인사말을 문자열에 저장하기**

모두 유효한 `String` 값입니다.

# 문자열 업데이트

더 많은 데이터를 넣으면 `Vec<T>` 의 내용처럼 문자열의 크기가 커지고 내용이 변경될 수 있습니다. 또한 `+` 연산자 또는 `format!` 매크로를 사용하여 편리하게 `String` 값을 연결할 수 있습니다.

## `push_str` 및 `push`를 사용하여 문자열에 추가하기

목록 8-15에 표시된 것처럼 `push_str` 메서드를 사용하여 문자열 슬라이스를 추가하여 문자열을 늘릴 수 있습니다.

```rust,editable
    let mut s = String::from("foo");
    s.push_str("bar");
```

**목록 8-15: `push_str` 메서드를 사용하여 `String` 에 문자열 슬라이스 추가하기**

이 두 줄 뒤에 `s`는 `foobar`를 포함합니다. `push_str` 메서드는 문자열 슬라이스를 사용하므로 매개변수의 소유권을 반드시 가져가고 싶지는 않습니다. 예를 들어, 목록 8-16의 코드에서는 `s1`에 내용을 추가한 후 `s2`를 사용할 수 있기를 원합니다.

```rust,editable
    let mut s1 = String::from("foo");
    let s2 = "bar";
    s1.push_str(s2);
    println!("s2 is {s2}");
```

**목록 8-16: 문자열에 내용을 추가한 후 문자열 슬라이스 사용하기**

`push_str` 메서드가 `s2`의 소유권을 가져간다면 마지막 줄에 해당 값을 출력할 수 없을 것입니다. 하지만 이 코드는 우리가 예상한 대로 작동합니다!

`push` 메서드는 하나의 문자를 매개변수로 받아 문자열에 추가합니다. 목록 8-17은 `push` 메서드를 사용하여 문자열에 문자 `l`을 추가합니다.

```rust,editable
    let mut s = String::from("lo");
    s.push('l');
```

**목록 8-17: `push`를 사용하여 문자열 값에 문자 하나 추가하기**

결과적으로 `s`에는 `lol`이 포함됩니다.

## `+` 연산자 또는 `format!` 매크로를 사용하여 연결하기

종종 두 개의 기존 문자열을 결합하고 싶을 때가 있습니다. 목록 8-18에 표시된 것처럼 `+` 연산자를 사용하는 것이 한 가지 방법입니다.

```rust,editable
    let s1 = String::from("Hello, ");
    let s2 = String::from("world!");
    let s3 = s1 + &s2; // note s1 has been moved here and can no longer be used
```

**목록 8-18: `+` 연산자를 사용하여 두 문자열 값을 새 문자열 값으로 결합하기**

문자열 `s3`에는 `Hello, world!` 추가 후 `s1`이 더 이상 유효하지 않은 이유와 `s2`에 대한 참조를 사용한 이유는 `+` 연산자를 사용할 때 호출되는 메서드의 시그니처와 관련이 있습니다. 연산자는 추가 메서드를 사용하며, 그 서명은 다음과 같습니다:

```rust
fn add(self, s: &str) -> String
```

표준 라이브러리에서 제네릭 및 관련 유형을 사용하여 정의된 추가를 볼 수 있습니다. 여기서는 구체적인 유형으로 대체했는데, 이 메서드를 문자열 값으로 호출할 때 일어나는 일입니다. 제네릭에 대해서는 10장에서 설명하겠습니다. 이 서명은 + 연산자의 까다로운 부분을 이해하는 데 필요한 단서를 제공합니다.

첫째, s2에는 &가 있어 첫 번째 문자열에 두 번째 문자열의 참조를 추가하고 있음을 의미합니다. 이는 add 함수의 s 매개변수 때문입니다. 문자열에 &str만 추가할 수 있고 두 개의 문자열 값을 함께 추가할 수는 없습니다. 하지만 잠깐만요. 추가할 두 번째 매개변수에 지정된 대로 &s2의 유형은 &str이 아니라 &String입니다. 그렇다면 목록 8-18이 컴파일되는 이유는 무엇일까요?

추가 호출에서 &s2를 사용할 수 있는 이유는 컴파일러가 &String 인수를 &str로 강제 변환할 수 있기 때문입니다. add 메서드를 호출할 때 Rust는 &s2를 &s2[..]로 바꾸는 디레프 강제를 사용합니다. 디레프 강제는 15장에서 더 자세히 설명하겠습니다. add는 s 매개변수의 소유권을 가지지 않으므로 이 연산 후에도 s2는 여전히 유효한 문자열이 됩니다.

둘째, 서명에서 self에는 &가 없기 때문에 add가 self의 소유권을 갖는다는 것을 알 수 있습니다. 즉, 목록 8-18의 s1은 add 호출로 이동하고 그 이후에는 더 이상 유효하지 않습니다. 따라서 s3 = s1 + &s2; 는 두 문자열을 복사하고 새 문자열을 생성하는 것처럼 보이지만, 실제로 이 문은 s1의 소유권을 가져와 s2의 내용 복사본을 추가한 다음 결과의 소유권을 반환합니다. 즉, 많은 복사본을 만드는 것처럼 보이지만 실제로는 복사하는 것보다 더 효율적으로 구현됩니다.

여러 문자열을 연결해야 하는 경우 + 연산자의 동작은 다루기 어려워집니다:

```rust,editable
    let s1 = String::from("tic");
    let s2 = String::from("tac");
    let s3 = String::from("toe");

    let s = s1 + "-" + &s2 + "-" + &s3;
```

이 시점에서 s는 틱택토가 됩니다. 모든 + 및 " 문자를 사용하면 무슨 일이 일어나고 있는지 확인하기가 어렵습니다. 좀 더 복잡한 방식으로 문자열을 결합하려면 대신 형식! 매크로를 사용할 수 있습니다:

```rust,editable
    let s1 = String::from("tic");
    let s2 = String::from("tac");
    let s3 = String::from("toe");

    let s = format!("{s1}-{s2}-{s3}");
```

이 코드는 또한 s를 틱택토로 설정합니다. format! 매크로는 println! 처럼 작동하지만, 출력을 화면에 인쇄하는 대신 내용이 포함된 문자열을 반환합니다. format! 매크로를 사용하는 코드 버전은 훨씬 더 읽기 쉽고, format! 매크로로 생성된 코드는 참조를 사용하므로 이 호출이 매개변수의 소유권을 갖지 않습니다.

## 문자열 인덱싱

다른 많은 프로그래밍 언어에서 문자열의 개별 문자를 인덱스로 참조하여 액세스하는 것은 유효하고 일반적인 작업입니다. 그러나 Rust에서 인덱싱 구문을 사용하여 문자열의 일부에 액세스하려고 하면 오류가 발생합니다. 목록 8-19의 잘못된 코드를 살펴보세요.

```rust,editable
    let s1 = String::from("hello");
    let h = s1[0];
```
**목록 8-19: 문자열로 인덱싱 구문을 사용하려고 시도하기**

이 코드는 다음과 같은 오류를 발생시킵니다:
```shell
$ cargo run
   Compiling collections v0.1.0 (file:///projects/collections)
error[E0277]: the type `str` cannot be indexed by `{integer}`
 --> src/main.rs:3:16
  |
3 |     let h = s1[0];
  |                ^ string indices are ranges of `usize`
  |
  = help: the trait `SliceIndex<str>` is not implemented for `{integer}`, which is required by `String: Index<_>`
  = note: you can use `.chars().nth()` or `.bytes().nth()`
          for more information, see chapter 8 in The Book: <https://doc.rust-lang.org/book/ch08-02-strings.html#indexing-into-strings>
  = help: the trait `SliceIndex<[_]>` is implemented for `usize`
  = help: for that trait implementation, expected `[_]`, found `str`
  = note: required for `String` to implement `Index<{integer}>`

For more information about this error, try `rustc --explain E0277`.
error: could not compile `collections` (bin "collections") due to 1 previous error
```

오류와 메모를 보면 알 수 있습니다: Rust 문자열은 인덱싱을 지원하지 않습니다. 하지만 왜 안 될까요? 이 질문에 답하기 위해서는 Rust가 문자열을 메모리에 어떻게 저장하는지 살펴볼 필요가 있습니다.

## 내부 표현

문자열은 `Vec<u8>`을 감싸는 래퍼입니다. 목록 8-14에서 제대로 인코딩된 UTF-8 예제 문자열 몇 가지를 살펴보겠습니다. 먼저, 이것입니다:

```rust,editable
    let hello = String::from("Hola");
```

이 경우 `len`은 `4`가 되며, 이는 문자열 `"Hola"`를 저장하는 벡터의 길이가 `4`바이트임을 의미합니다. UTF-8로 인코딩할 경우 각 문자는 `1`바이트가 소요됩니다. 그러나 다음 줄은 놀랄 수 있습니다(이 문자열은 숫자 3이 아닌 키릴 문자의 대문자 Ze로 시작합니다):

```rust,editable
    let hello = String::from("Здравствуйте");
```

문자열의 길이를 묻는다면 12라고 말할 수 있습니다. 실제로 Rust의 대답은 24입니다. 해당 문자열의 각 유니코드 스칼라 값은 2바이트의 저장 공간을 차지하기 때문에 "Здравствуйте"를 UTF-8로 인코딩하는 데 필요한 바이트 수입니다. 따라서 문자열의 바이트에 대한 인덱스가 항상 유효한 유니코드 스칼라 값과 상관관계가 있는 것은 아닙니다. 이를 설명하기 위해 다음 유효하지 않은 Rust 코드를 살펴보겠습니다:

```rust,editable
let hello = "Здравствуйте";
let answer = &hello[0];
```

답변의 첫 글자가 З가 아니라는 것을 이미 알고 계실 것입니다. UTF-8로 인코딩할 때 З의 첫 바이트는 208이고 두 번째 바이트는 151이므로 실제로는 208이 되어야 하지만 208은 그 자체로는 유효한 문자가 아닙니다. 사용자가 이 문자열의 첫 글자를 요청하는 경우 208을 반환하는 것은 사용자가 원하는 것이 아닐 가능성이 높지만, Rust가 바이트 인덱스 0에 가지고 있는 유일한 데이터입니다. 일반적으로 사용자는 문자열에 라틴 문자만 포함되어 있어도 바이트 값을 반환하는 것을 원하지 않습니다. &"hello"[0]가 바이트 값을 반환하는 유효한 코드였다면 h가 아닌 104를 반환할 것입니다.

따라서 예상치 못한 값을 반환하고 즉시 발견되지 않을 수 있는 버그를 방지하기 위해 Rust는 이 코드를 전혀 컴파일하지 않고 개발 프로세스 초기에 오해를 방지합니다.

## 바이트와 스칼라 값, 그리고 그래핌 클러스터! 오 이런!

UTF-8에 대한 또 다른 요점은 Rust의 관점에서 문자열을 바이트, 스칼라 값, 그래핌핌 클러스터(우리가 문자라고 부르는 것에 가장 가까운 것)로 보는 세 가지 관련 방법이 실제로 존재한다는 것입니다.

힌디어 단어 'नमस्ते'를 데바나가리 문자로 작성된 것을 보면 다음과 같이 u8 값의 벡터로 저장되어 있습니다:

```rust
[224, 164, 168, 224, 164, 174, 224, 164, 184, 224, 165, 141, 224, 164, 164,
224, 165, 135]
```

이는 18바이트이며 컴퓨터가 궁극적으로 이 데이터를 저장하는 방식입니다. Rust의 문자 유형인 유니코드 스칼라 값으로 보면 이 바이트는 다음과 같이 보입니다:

```rust
['न', 'म', 'स', '्', 'त', 'े']
```

여기에는 6개의 문자 값이 있지만 네 번째와 여섯 번째는 문자가 아니라 그 자체로는 의미가 없는 분음 부호입니다. 마지막으로, 이를 그래핌 클러스터로 보면 힌디어 단어를 구성하는 네 글자가 무엇인지 알 수 있습니다:

```rust
["न", "म", "स्", "ते"]
```

Rust는 컴퓨터가 저장하는 원시 문자열 데이터를 해석하는 다양한 방법을 제공하여 데이터가 어떤 인간 언어로 되어 있든 각 프로그램이 필요한 해석을 선택할 수 있도록 합니다.

Rust에서 문자열로 색인하여 문자를 가져오는 것을 허용하지 않는 마지막 이유는 색인 작업이 항상 일정한 시간(O(1))이 걸릴 것으로 예상되기 때문입니다. 하지만 문자열에서는 이러한 성능을 보장할 수 없는데, 그 이유는 Rust가 처음부터 색인까지 내용을 살펴보고 유효한 문자가 몇 개 있는지 확인해야 하기 때문입니다.


## 문자열 슬라이싱

문자열 인덱싱 작업의 반환 유형이 바이트 값, 문자, 그래핌 클러스터 또는 문자열 조각 중 무엇이 되어야 하는지 명확하지 않기 때문에 문자열로 인덱싱하는 것은 종종 좋지 않은 생각입니다. 따라서 인덱스를 사용하여 문자열 조각을 만들어야 하는 경우 Rust는 사용자에게 더 구체적으로 알려달라고 요청합니다.

단일 숫자로 []를 사용하여 인덱싱하는 대신 범위로 []를 사용하여 특정 바이트가 포함된 문자열 슬라이스를 만들 수 있습니다:

```rust,editable
let hello = "Здравствуйте";

let s = &hello[0..4];
```

여기서 s는 문자열의 처음 4바이트를 포함하는 &str이 됩니다. 앞서 각 문자는 2바이트이므로 s는 Зд이 될 것이라고 언급했습니다.

만약 &hello[0..1]과 같이 문자의 바이트 중 일부만 슬라이스하려고 한다면, Rust는 벡터에서 잘못된 인덱스에 액세스하는 것과 같은 방식으로 런타임에 패닉에 빠질 것입니다:

```shell
$ cargo run
   Compiling collections v0.1.0 (file:///projects/collections)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.43s
     Running `target/debug/collections`
thread 'main' panicked at src/main.rs:4:19:
byte index 1 is not a char boundary; it is inside 'З' (bytes 0..2) of `Здравствуйте`
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
```
범위가 있는 문자열 조각을 만들면 프로그램이 충돌할 수 있으므로 주의해야 합니다.

## 문자열 순회 메서드

문자열 조각을 연산하는 가장 좋은 방법은 문자를 원하는지 바이트를 원하는지 명시하는 것입니다. 개별 유니코드 스칼라 값의 경우 chars 메서드를 사용합니다. "Зд"에서 char 메서드를 호출하면 문자 유형의 두 값이 분리되어 반환되며, 결과를 반복하여 각 요소에 액세스할 수 있습니다:

```rust,editable
for c in "Зд".chars() {
    println!("{c}");
}
```

이 코드는 다음과 같이 인쇄됩니다:
```
З
д
```

또는 바이트 메서드는 각 원시 바이트를 반환하므로 도메인에 적합할 수 있습니다:

```
208
151
208
180
```

하지만 유효한 유니코드 스칼라 값은 1바이트 이상으로 구성될 수 있다는 점을 기억하세요.

Devanagari 스크립트와 마찬가지로 문자열에서 자소문자 클러스터를 가져오는 것은 복잡하므로 이 기능은 표준 라이브러리에서 제공되지 않습니다. 이 기능이 필요한 경우 [crates.io](https://crates.io/)에서 크레이트를 사용할 수 있습니다.

## 문자열은 간단하지 않습니다

요약하자면 문자열은 복잡합니다. 프로그래밍 언어마다 프로그래머에게 이 복잡성을 표현하는 방법에 대해 다른 선택을 합니다. Rust는 문자열 데이터를 올바르게 처리하는 것을 모든 Rust 프로그램의 기본 동작으로 선택했으며, 이는 프로그래머가 UTF-8 데이터를 처리할 때 미리 더 많은 생각을 해야 한다는 것을 의미합니다. 이 절충안은 다른 프로그래밍 언어보다 문자열의 복잡성을 더 많이 노출하지만, 개발 수명 주기 후반에 ASCII가 아닌 문자와 관련된 오류를 처리할 필요가 없게 해줍니다.

다행히도 표준 라이브러리에는 이러한 복잡한 상황을 올바르게 처리할 수 있도록 문자열 및 &str 유형에 기반한 많은 기능이 포함되어 있습니다. 문자열에서 검색할 때 사용하는 포함, 문자열의 일부를 다른 문자열로 대체할 때 사용하는 대체와 같은 유용한 메서드는 설명서를 확인하시기 바랍니다.

이제 조금 덜 복잡한 해시 맵으로 전환해 보겠습니다!