# 소유권이란 무엇인가?

소유권은 Rust의 가장 독특한 특징입니다. 이 기능 덕분에 Rust는 가비지 컬렉터 없이도 메모리 안전성을 보장할 수 있습니다. 따라서 소유권이 어떻게 작동하는지 이해하는 것이 중요합니다. 이 장에서는 소유권과 관련된 여러 기능인 빌림(borrow), 슬라이스(slice), 그리고 Rust가 메모리에 데이터를 어떻게 배치하는지에 대해 다룰 것입니다.

## 소유권 규칙

먼저 소유권 규칙을 살펴보겠습니다. 이 규칙들을 기억하면서 예제를 통해 설명하겠습니다:

1. Rust의 각 값은 소유자(owner)라고 불리는 변수를 가집니다.
2. 한 번에 하나의 소유자만 존재할 수 있습니다.
3. 소유자가 범위(scope)를 벗어나면 값은 버려집니다(dropped).

## 변수의 범위

변수의 범위는 프로그램 내에서 해당 변수가 유효한 부분을 말합니다. 예를 들어:

```rust
{                      // s는 여기서 유효하지 않습니다. 아직 선언되지 않았기 때문입니다.
    let s = "hello";   // s는 여기서부터 유효합니다.
    // s를 사용하는 코드
}                      // 이 범위는 끝났습니다. s는 더 이상 유효하지 않습니다.
```

## String 타입

문자열 리터럴(string literals)은 불변(immutable)이며, 컴파일 시점에 알려진 문자열 값에 적합합니다. 하지만 문자열 값이 변경될 수 있어야 하는 경우가 있습니다. 이를 위해 Rust는 `String` 타입을 제공합니다. 이 타입은 힙(heap)에 할당되므로 컴파일 시점에 알려지지 않은 텍스트를 저장할 수 있습니다.

```rust
let mut s = String::from("hello");
s.push_str(", world!"); // push_str()은 리터럴을 String에 추가합니다.
println!("{}", s); // "hello, world!"를 출력합니다.
```

## 메모리와 할당

문자열 리터럴의 경우, 내용물은 컴파일 시점에 알려져 있으므로 텍스트가 최종 실행 파일에 직접 하드코딩됩니다. 이는 문자열 리터럴이 빠르고 효율적인 이유입니다. 하지만 이는 불변성(immutability)을 의미합니다.

`String` 타입의 경우, 힙에 메모리를 할당해야 하므로:

1. 런타임에 운영체제로부터 메모리를 요청해야 합니다.
2. `String`의 사용이 끝났을 때 이 메모리를 운영체제에 반환할 방법이 필요합니다.

Rust는 두 번째 부분을 다르게 처리합니다: 변수가 자신이 속한 범위를 벗어나면 자동으로 메모리가 반환됩니다.

```rust
{
    let s = String::from("hello"); // s는 여기서부터 유효합니다.
    // s를 사용하는 코드
}                                  // 이 범위는 끝났습니다. s는 더 이상 유효하지 않습니다.
```

## 변수와 데이터의 상호작용: 이동(Move)

여러 변수가 같은 데이터와 상호작용하는 방식은 Rust에서 다른 언어들과 다릅니다. 예를 들어:

```rust
let x = 5;
let y = x;
```

이 경우, 정수는 알려진 고정 크기를 가지는 단순한 값이므로 두 개의 5 값이 스택에 푸시됩니다.

하지만 `String` 버전은 다릅니다:

```rust
let s1 = String::from("hello");
let s2 = s1;
```

이 경우, `String`은 힙에 할당된 데이터를 가리키는 포인터를 포함하는 구조체입니다. `s1`을 `s2`에 할당하면, `String` 데이터가 복사되는 것이 아니라 포인터가 복사됩니다. 이는 두 변수가 같은 데이터를 가리키게 됨을 의미합니다.

Rust는 이 경우 `s1`을 더 이상 유효하지 않은 것으로 간주하고, `s1`이 범위를 벗어날 때 메모리를 해제하지 않습니다. 이를 "이동(move)"이라고 합니다.

## 변수와 데이터의 상호작용: 클론(Clone)

만약 힙 데이터의 "깊은" 복사본을 만들고 싶다면, `clone` 메서드를 사용할 수 있습니다:

```rust
let s1 = String::from("hello");
let s2 = s1.clone();
```

이 경우, 힙 데이터가 실제로 복사됩니다.

## 스택에만 있는 데이터: 복사(Copy)

정수와 같은 타입은 스택에 저장되며, 복사가 간단합니다. 이러한 타입들은 `Copy` 트레이트를 구현합니다. `Copy` 트레이트가 구현된 타입의 변수는 이동되지 않고 복사됩니다.

`Copy`가 될 수 있는 타입의 예시:
- 모든 정수 타입 (예: `u32`)
- 불리언 타입 (`bool`)
- 모든 부동 소수점 타입 (예: `f64`)
- 문자 타입 (`char`)
- `Copy` 타입만 포함하는 튜플 (예: `(i32, i32)`)

## 소유권과 함수

함수에 값을 전달하는 것은 변수에 값을 할당하는 것과 유사합니다. 함수에 변수를 전달하면 이동이나 복사가 발생합니다:

```rust
fn main() {
    let s = String::from("hello");  // s가 범위 안으로 들어옵니다.
    takes_ownership(s);             // s의 값이 함수 안으로 이동됩니다.
                                    // 그리고 여기서는 더 이상 유효하지 않습니다.
    let x = 5;                      // x가 범위 안으로 들어옵니다.
    makes_copy(x);                  // x가 함수 안으로 이동될 것입니다만,
                                    // i32는 Copy이므로, x를 이후에 계속 사용해도 됩니다.
} // 여기서 x가 범위를 벗어나고, s도 범위를 벗어납니다. 하지만 s의 값은 이동되었으므로
  // 아무 일도 일어나지 않습니다.

fn takes_ownership(some_string: String) { // some_string이 범위 안으로 들어옵니다.
    println!("{}", some_string);
} // 여기서 some_string이 범위를 벗어나고 `drop`이 호출됩니다.
  // 메모리가 해제됩니다.

fn makes_copy(some_integer: i32) { // some_integer가 범위 안으로 들어옵니다.
    println!("{}", some_integer);
} // 여기서 some_integer가 범위를 벗어납니다. 아무 일도 일어나지 않습니다.
```

## 반환 값과 범위

반환 값도 소유권을 이전할 수 있습니다:

```rust
fn main() {
    let s1 = gives_ownership();         // gives_ownership은 반환 값을 s1에게 이동시킵니다.
    let s2 = String::from("hello");     // s2가 범위 안으로 들어옵니다.
    let s3 = takes_and_gives_back(s2);  // s2는 takes_and_gives_back 안으로 이동되고,
                                        // 이 함수가 반환 값을 s3에게 이동시킵니다.
} // 여기서 s3가 범위를 벗어나고 버려집니다. s2는 이동되었으므로 아무 일도 일어나지 않습니다.
  // s1도 범위를 벗어나고 버려집니다.

fn gives_ownership() -> String {             // gives_ownership은 반환 값을 호출자에게 이동시킵니다.
    let some_string = String::from("hello"); // some_string이 범위 안으로 들어옵니다.
    some_string                              // some_string이 반환되고 호출자에게 이동됩니다.
}

fn takes_and_gives_back(a_string: String) -> String { // a_string이 범위 안으로 들어옵니다.
    a_string  // a_string이 반환되고 호출자에게 이동됩니다.
}
```

변수의 소유권은 매번 같은 패턴을 따릅니다: 값을 다른 변수에 할당하면 이동됩니다. 힙에 데이터를 가진 변수가 범위를 벗어나면, 다른 변수가 소유권을 가져가지 않았다면 `drop`이 호출되어 메모리가 해제됩니다.