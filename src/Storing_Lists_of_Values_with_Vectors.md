# 벡터를 사용해 값들 저장하기

첫 번째로 살펴볼 컬렉션 타입은 벡터라고도 하는 `Vec<T>`입니다. 벡터를 사용하면 모든 값을 메모리에 나란히 배치하는 단일 데이터 구조에 둘 이상의 값을 저장할 수 있습니다. 벡터는 같은 타입의 값만 저장할 수 있습니다. 파일의 텍스트 줄이나 장바구니에 있는 항목의 가격과 같은 항목 목록이 있을 때 유용합니다.

## 새 벡터 만들기
새로운 빈 벡터를 생성하려면 목록 8-1에 표시된 것처럼 `Vec::new` 함수를 호출합니다.


```rust,editable

	let v: Vec<i32> = Vec::new();

```
**목록 8-1: `i32` 타입의 값을 저장하기 위한 새 빈 벡터 만들기**

여기에 타입 어노테이션을 추가했습니다. 이 벡터에 값을 삽입하지 않았기 때문에 Rust는 우리가 어떤 종류의 요소를 저장하려는지 알지 못합니다. 이것이 중요한 포인트입니다. 벡터는 제네릭을 사용해 구현되며, 자체 타입에 제네릭을 사용하는 방법은 10장에서 다룰 것입니다. 지금은 표준 라이브러리에서 제공하는 `Vec<T>` 타입은 모든 타입을 담을 수 있다는 것을 알아두세요. 특정 타입을 담을 벡터를 만들 때는 꺾쇠 괄호 안에 타입을 지정할 수 있습니다. 목록 8-1에서는 v의 `Vec<T>`가 `i32` 타입의 요소를 보유하도록 지시했습니다.

초기 값으로 `Vec<T>`를 생성하는 경우가 더 많으며, 저장하려는 값의 타입을 Rust가 추론하므로 이 타입 어노테이션을 수행할 필요가 거의 없습니다. Rust는 편리하게도 `vec!` 매크로를 제공하여 사용자가 지정한 값을 저장하는 새 벡터를 생성합니다. 목록 8-2는 값 1, 2, 3을 포함하는 새로운 `Vec<i32>`를 생성합니다. 정수 타입은 3장의 ["데이터 타입"](./Data_Types.md) 섹션에서 설명한 대로 기본 정수 타입이기 때문에 `i32`입니다.

```rust,editable

	let v = vec![1, 2, 3];

```

**목록 8-2: 값이 포함된 새 벡터 만들기**

초기 `i32` 값을 제공했기 때문에 Rust는 `v`의 타입이 `Vec<i32>`라고 추론할 수 있으며 타입 어노테이션은 필요하지 않습니다. 다음으로 벡터를 수정하는 방법을 살펴보겠습니다.

## 벡터 갱신하기

벡터를 만든 다음 요소를 추가하려면 목록 8-3에 표시된 것처럼 푸시 방법을 사용할 수 있습니다.

```rust,editable

    let mut v = Vec::new();

    v.push(5);
    v.push(6);
    v.push(7);
    v.push(8);

```

**목록 8-3: `push` 메서드를 사용하여 벡터에 값 추가하기**

다른 변수와 마찬가지로 값을 변경하려면 3장에서 설명한 대로 `mut` 키워드를 사용하여 변수를 변경 가능하게 만들어야 합니다. 안에 넣는 숫자는 모두 `i32` 타입이며, Rust는 데이터에서 이를 추론하므로 `Vec<i32>` 어노테이션이 필요하지 않습니다.

## 벡터의 요소 읽기

벡터에 저장된 값을 참조하는 방법에는 인덱싱 또는 `get` 메서드를 사용하는 두 가지 방법이 있습니다. 다음 예제에서는 이러한 함수에서 반환되는 값의 타입을 더욱 명확하게 하기 위해 주석을 달았습니다.

목록 8-4는 인덱싱 구문과 `get` 메서드를 사용하여 벡터의 값에 액세스하는 두 가지 방법을 보여줍니다.

```rust,editable
    let v = vec![1, 2, 3, 4, 5];

    let third: &i32 = &v[2];
    println!("The third element is {third}");

    let third: Option<&i32> = v.get(2);
    match third {
        Some(third) => println!("The third element is {third}"),
        None => println!("There is no third element."),
    }
```

**목록 8-4: 인덱싱 구문 사용 및 `get` 메서드를 사용하여 벡터의 항목에 액세스하기**

여기서 몇 가지 세부 사항을 참고하세요. 벡터는 0부터 시작하여 숫자로 인덱싱되므로 세 번째 요소를 얻기 위해 인덱스 값 `2`를 사용합니다. `&` 와 `[]`를 사용하면 인덱스 값에 있는 요소에 대한 참조를 얻을 수 있습니다. 인자로 전달된 인덱스와 함께 `get` 메서드를 사용하면 `match와` 함께 사용할 수 있는 `Option<&T>`가 반환됩니다.

Rust는 요소를 참조하는 이 두 가지 방법을 제공하므로 기존 요소의 범위를 벗어난 인덱스 값을 사용하려고 할 때 프로그램이 어떻게 작동할지 선택할 수 있습니다. 예를 들어 목록 8-5에 표시된 것처럼 5개의 요소로 구성된 벡터가 있고 각 기술을 사용하여 인덱스 100에 있는 요소에 액세스하려고 할 때 어떤 일이 발생하는지 살펴봅시다.

```rust,editable
    let v = vec![1, 2, 3, 4, 5];

    let does_not_exist = &v[100];
    let does_not_exist = v.get(100);
```

**목록 8-5: 5개의 요소가 포함된 벡터에서 인덱스 100의 요소에 액세스하려는 시도**

이 코드를 실행하면 첫 번째 `[]` 메서드는 존재하지 않는 요소를 참조하기 때문에 프로그램이 패닉 상태에 빠지게 됩니다. 이 메서드는 벡터의 끝을 지나서 요소에 액세스하려고 할 때 프로그램이 충돌하도록 하려는 경우에 가장 적합합니다.

`get` 메서드에 벡터 밖에 있는 인덱스가 전달되면 당황하지 않고 `None`을 반환합니다. 일반적인 상황에서 벡터 범위를 벗어난 요소에 액세스하는 경우가 가끔 발생할 수 있는 경우 이 메서드를 사용할 수 있습니다. 그러면 코드에 6장에서 설명한 대로 `Some(&element)` 또는 `None`이 있는 경우를 처리하는 로직이 생깁니다. 예를 들어, 인덱스는 사람이 숫자를 입력하는 데서 나올 수 있습니다. 사용자가 실수로 너무 큰 숫자를 입력해 프로그램에 `None` 값이 나오는 경우, 현재 벡터에 몇 개의 항목이 있는지 알려주고 유효한 값을 입력할 수 있는 기회를 다시 제공할 수 있습니다. 오타로 인해 프로그램이 다운되는 것보다 훨씬 더 사용자 친화적일 것입니다!

프로그램에 유효한 참조가 있는 경우, 차용 검사기는 소유권 및 차용 규칙(4장에서 다룸)을 적용하여 이 참조와 벡터의 내용에 대한 다른 참조가 유효하게 유지되도록 합니다. 같은 범위에서 변경 가능한 참조와 변경 불가능한 참조를 가질 수 없다는 규칙을 기억하세요. 이 규칙은 목록 8-6에서 벡터의 첫 번째 요소에 대한 변경 불가능한 참조를 보유하고 끝에 요소를 추가하려고 시도하는 경우에 적용됩니다. 함수의 뒷부분에서 해당 요소를 참조하려고 하면 이 프로그램은 작동하지 않습니다.

```rust,editable
    let mut v = vec![1, 2, 3, 4, 5];

    let first = &v[0];

    v.push(6);

    println!("The first element is: {first}");
```

**목록 8-6: 항목에 대한 참조를 보유한 상태에서 벡터에 요소를 추가하려고 시도하기**

이 코드를 컴파일하면 이 오류가 발생합니다:

```shell
$ cargo run
   Compiling collections v0.1.0 (file:///projects/collections)
error[E0502]: cannot borrow `v` as mutable because it is also borrowed as immutable
 --> src/main.rs:6:5
  |
4 |     let first = &v[0];
  |                  - immutable borrow occurs here
5 |
6 |     v.push(6);
  |     ^^^^^^^^^ mutable borrow occurs here
7 |
8 |     println!("The first element is: {first}");
  |                                     ------- immutable borrow later used here

For more information about this error, try `rustc --explain E0502`.
error: could not compile `collections` (bin "collections") due to 1 previous error
```

목록 8-6의 코드는 작동하는 것처럼 보일 수 있습니다. 왜 첫 번째 요소에 대한 참조가 벡터 끝의 변경 사항에 신경을 써야 할까요? 이 오류는 벡터의 작동 방식 때문입니다. 벡터는 메모리에서 값을 나란히 배치하기 때문에 벡터 끝에 새 요소를 추가하려면 현재 벡터가 저장되어 있는 모든 요소를 나란히 배치할 공간이 충분하지 않은 경우 새 메모리를 할당하고 이전 요소를 새 공간에 복사해야 할 수 있습니다. 이 경우 첫 번째 요소에 대한 참조는 할당 해제된 메모리를 가리키게 됩니다. 차용 규칙은 프로그램이 이러한 상황에 처하는 것을 방지합니다.

> 참고: `Vec<T>` 타입의 구현에 대한 자세한 내용은 ["러스토노미콘"](https://doc.rust-lang.org/nomicon/vec/vec.html)을 참조하세요.

## 벡터의 값 반복하기

벡터의 각 요소에 차례로 액세스하려면 인덱스를 사용하여 한 번에 하나씩 액세스하는 대신 모든 요소를 반복합니다. 목록 8-7은 `for` 루프를 사용하여 `i32` 값의 벡터에서 각 요소에 대한 불변 참조를 가져와서 출력하는 방법을 보여줍니다.

```rust,editable
    let v = vec![100, 32, 57];
    for i in &v {
        println!("{i}");
    }
```

**목록 8-7: `for` 루프를 사용하여 요소를 반복하여 벡터의 각 요소를 인쇄합니다.**

또한 가변 벡터의 각 요소에 대한 가변 참조를 반복하여 모든 요소를 변경할 수 있습니다. 목록 8-8의 `for` 루프는 각 요소에 `50`을 추가합니다.

```rust,editable
    let mut v = vec![100, 32, 57];
    for i in &mut v {
        *i += 50;
    }
```

**목록 8-8: 벡터의 요소에 대한 변경 가능한 참조 반복하기**

가변 참조가 가리키는 값을 변경하려면 `+=` 연산자를 사용하기 전에 `*` 역참조 연산자를 사용하여 `i`의 값에 도달해야 합니다. 역참조 연산자에 대한 자세한 내용은 15장의 '역참조 연산자를 사용하여 값에 대한 포인터 따라가기' 섹션에서 설명합니다.

벡터를 불변적이든 가변적이든 반복하는 것은 차용 검사기의 규칙 때문에 안전합니다. 목록 8-7과 목록 8-8의 `for` 루프 본문에서 항목을 삽입하거나 제거하려고 하면 목록 8-6의 코드에서 발생한 것과 유사한 컴파일러 오류가 발생합니다. `for` 루프가 보유하고 있는 벡터에 대한 참조는 전체 벡터의 동시 수정을 방지합니다.

## 열거형을 사용하여 여러 타입 저장하기

벡터는 같은 타입의 값만 저장할 수 있습니다. 이는 불편할 수 있습니다. 서로 다른 타입의 항목 목록을 저장해야 하는 사용 사례가 분명히 존재합니다. 다행히도 열거형의 변형은 동일한 열거형 타입으로 정의되므로 서로 다른 타입의 요소를 표현하기 위해 하나의 타입이 필요한 경우 열거형을 정의하여 사용할 수 있습니다!

예를 들어 행의 일부 열에 정수, 부동 소수점 숫자, 문자열이 포함된 스프레드시트의 행에서 값을 가져오고 싶다고 가정해 보겠습니다. 다양한 값 타입을 보유하는 열거형을 정의할 수 있으며, 모든 열거형 변형은 열거형의 타입과 동일한 타입으로 간주됩니다. 그런 다음 해당 열거형을 보유할 벡터를 생성하여 궁극적으로 다양한 타입을 보유할 수 있습니다. 목록 8-9에서 이를 시연했습니다.

```rust,editable
    enum SpreadsheetCell {
        Int(i32),
        Float(f64),
        Text(String),
    }

    let row = vec![
        SpreadsheetCell::Int(3),
        SpreadsheetCell::Text(String::from("blue")),
        SpreadsheetCell::Float(10.12),
    ];
```

**목록 8-9: 하나의 벡터에 다양한 타입의 값을 저장하는 열거형 정의하기**

Rust는 컴파일 시 벡터에 어떤 타입이 포함될지 알아야 각 요소를 저장하는 데 필요한 힙의 메모리 양을 정확히 알 수 있습니다. 또한 이 벡터에 어떤 타입이 허용되는지 명시해야 합니다. Rust가 벡터에 어떤 타입이든 허용한다면, 하나 이상의 타입이 벡터의 요소에 대해 수행되는 연산에서 오류를 일으킬 가능성이 있습니다. 열거형과 `match` 표현식을 사용하면 6장에서 설명한 대로 컴파일 시 모든 가능한 경우를 처리할 수 있도록 Rust가 보장합니다.
런타임에 프로그램이 벡터에 저장할 전체 타입 집합을 알지 못하면 열거형 기법이 작동하지 않습니다. 대신 17장에서 다룰 특성 객체를 사용할 수 있습니다.
이제 벡터를 사용하는 가장 일반적인 방법 몇 가지를 살펴보았으니, 표준 라이브러리에서 `Vec<T>`에 정의된 많은 유용한 메서드에 대한 API 설명서를 검토해 보세요. 예를 들어, `push` 메서드 외에도 `pop` 메서드는 마지막 요소를 제거하고 반환합니다.

## 벡터를 떨어뜨리면 해당 요소가 떨어집니다.
다른 구조체와 마찬가지로 벡터는 목록 8-10에 주석이 달린 것처럼 범위를 벗어나면 해제됩니다.

```rust,editable
    {
        let v = vec![1, 2, 3, 4];

        // do stuff with v
    } // <- v goes out of scope and is freed here
```
**목록 8-10: 벡터와 그 요소가 놓인 위치 표시하기**

벡터가 삭제되면 벡터의 모든 내용도 삭제되므로 벡터에 포함된 정수가 정리됩니다. 차용 검사기는 벡터의 내용에 대한 모든 참조가 벡터 자체가 유효한 동안에만 사용되도록 합니다.

다음 컬렉션 타입으로 넘어가 보겠습니다: `String`!

